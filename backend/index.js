/**
 * /////////////////////////////////////////////////////////////////////////////////////////////////////////////
 * 1) How it works:
 *
 * Generate OTP:
 *    A random 6-digit OTP is generated by generateOtp().
 *
 * Send OTP:
 *    The OTP is emailed via Gmail SMTP using Nodemailer.
 *    Set EMAIL_USER and EMAIL_PASS in .env to valid credentials/App Password.
 *
 * User Input:
 *    Frontend sends /request-otp { email }
 *    Frontend sends /verify-otp { email, code }
 *
 * Verify OTP:
 *    We look up the OTP in MongoDB (auto-expiring after 5 minutes).
 * /////////////////////////////////////////////////////////////////////////////////////////////////////////////
 *
 * 2) Instructions:
 *
 *   a. Enable App Passwords in Gmail:
 *      • Google Account → Security → 2-Step Verification → App Passwords
 *      • Generate for “Mail” + platform of your choice
 *
 *   b. Verify Credentials:
 *      • EMAIL_USER matches the account that generated the App Password
 *
 *   c. Less-secure apps:
 *      • If not using App Passwords, enable “Less secure app access” (not recommended)
 */

require('dotenv').config();
const express    = require('express');
const mongoose   = require('mongoose');
const bodyParser = require('body-parser');
const nodemailer = require('nodemailer');
const Otp        = require('./models/Otp');

const app = express();
app.use(bodyParser.json());

// 1) Connect to MongoDB
mongoose.connect(process.env.MONGO_URI, {
  useNewUrlParser:    true,
  useUnifiedTopology: true,
})
.then(() => console.log('✅ MongoDB connected'))
.catch(err => console.error('❌ MongoDB error:', err));

// 2) Generate 6-digit OTP
function generateOtp() {
  return Math.floor(100000 + Math.random() * 900000).toString();
}

// 3) Configure Nodemailer
const transporter = nodemailer.createTransport({
  service: 'gmail',
  auth: {
    user: process.env.EMAIL_USER,
    pass: process.env.EMAIL_PASS9
  }
});

// 4) POST /request-otp
app.post('/request-otp', async (req, res) => {
  const { email } = req.body;
  if (!email) return res.status(400).json({ error: 'Email is required' });

  const code = generateOtp();
  try {
    // a) Save OTP (expires in 5 min via TTL)
    await Otp.create({ email, code });

    // b) Send OTP via email
    await transporter.sendMail({
      from: `"Security Team" <${process.env.EMAIL_USER}>`,
      to: email,
      subject: 'Your OTP Code',
      text: `Dear User,\n\nYour OTP code for login is: ${code}\n\nThis code is valid for 5 minutes.\n\nBest regards,\nYour Security Team`
    });

    res.json({ message: 'OTP sent to email' });
  } catch (err) {
    console.error('Send OTP error:', err);
    res.status(500).json({ error: 'Failed to send OTP' });
  }
});

// 5) POST /verify-otp
app.post('/verify-otp', async (req, res) => {
  const { email, code } = req.body;
  if (!email || !code) return res.status(400).json({ error: 'Email and code are required' });

  try {
    // Look for matching, unexpired OTP
    const record = await Otp.findOne({ email, code });
    if (!record) {
      return res.status(400).json({ success: false, message: 'Invalid or expired OTP' });
    }

    // Optionally delete to prevent reuse
    await Otp.deleteMany({ email, code });

    res.json({ success: true, message: 'Login successful!' });
  } catch (err) {
    console.error('Verify OTP error:', err);
    res.status(500).json({ error: 'Verification failed' });
  }
});

// 6) Start
const PORT = process.env.PORT || 3000;
app.listen(PORT, () => console.log(`🚀 Server running on port ${PORT}`));
